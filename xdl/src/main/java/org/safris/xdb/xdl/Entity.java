package org.safris.xdb.xdl;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.Vector;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;

@MappedSuperclass
public abstract class Entity {
  private static final Map<Class,Field[]> classToPrimaryKeys = new HashMap<Class,Field[]>();
  private static final Map<Class,Map<Field,GeneratedKey.Strategy>> classToGeneratedFields = new HashMap<Class,Map<Field,GeneratedKey.Strategy>>();

  protected static void init(final Class entityClass) {
    final Map<Field,GeneratedKey.Strategy> fieldToGeneratedKeys = new HashMap<Field,GeneratedKey.Strategy>();
    classToGeneratedFields.put(entityClass, fieldToGeneratedKeys);
    final Vector<Field> keyColumns = new Vector<Field>();
    Class cls = entityClass;
    while (cls != null) {
      final Field[] fields = cls.getDeclaredFields();
      for (Field field : fields) {
        if (field.getAnnotation(Id.class) != null) {
          keyColumns.add(field);
          final GeneratedKey generatedKey = field.getAnnotation(GeneratedKey.class);
          if (generatedKey != null)
            fieldToGeneratedKeys.put(field, generatedKey.strategy());
        }
      }

      cls = cls.getSuperclass();
    }

    classToPrimaryKeys.put(entityClass, keyColumns.toArray(new Field[keyColumns.size()]));
  }

  /**
   * Informs whether all primary keys have been set on this entity.
   *
   * @param autogenerate If true, and a primary key is null, this method will generate a key.
   *
   * @return true, if and only if all keys were present before execution of this method, regardless of autogenerated keys.
   */
  public boolean isPrimaryKeyPresent() {
    final Field[] primaryFields = classToPrimaryKeys.get(getClass());
    try {
      for (int i = 0; i < primaryFields.length; i++)
        if (primaryFields[i].get(this) == null)
          return false;
    }
    catch (IllegalAccessException e) {
      return false;
    }

    return true;
  }

  @PrePersist
  @PreUpdate
  public void generateKeys() {
    final Field[] primaryFields = classToPrimaryKeys.get(getClass());
    try {
      for (Field field : primaryFields) {
        field.setAccessible(true);
        final boolean hasValue = field.get(this) != null;
        if (hasValue)
          continue;

        final Map<Field,GeneratedKey.Strategy> fieldToGeneratedKeys = classToGeneratedFields.get(getClass());
        if (fieldToGeneratedKeys == null)
          continue;

        final GeneratedKey.Strategy strategy = fieldToGeneratedKeys.get(field);
        if (strategy == GeneratedKey.Strategy.UUID)
          field.set(this, UUID.randomUUID().toString());
      }
    }
    catch (IllegalAccessException e) {
    }
  }
}
