/* Copyright (c) 2014 JAX-DB
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * You should have received a copy of The MIT License (MIT) along with this
 * program. If not, see <http://opensource.org/licenses/MIT/>.
 */

package org.jaxdb.jsql.generator;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.annotation.Generated;

import org.jaxdb.ddlx.DDLxAudit;
import org.jaxdb.ddlx.GeneratorExecutionException;
import org.jaxdb.jsql.EntityEnum;
import org.jaxdb.jsql.GenerateOn;
import org.jaxdb.jsql.Schema;
import org.jaxdb.jsql.type;
import org.jaxdb.vendor.Dialect;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Bigint;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Binary;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Blob;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Boolean;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Char;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Clob;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Column;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Date;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Datetime;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Decimal;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Documented;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Double;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Enum;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Float;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Int;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Integer;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Smallint;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Time;
import org.jaxdb.www.ddlx_0_4.xLygluGCXAA.$Tinyint;
import org.jaxdb.www.jsql_0_4.xLygluGCXAA.$Table;
import org.jaxsb.runtime.Bindings;
import org.libj.lang.Classes;
import org.libj.lang.Identifiers;
import org.libj.lang.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3.www._2001.XMLSchema;
import org.xml.sax.SAXException;

public class Generator {
  private static final Logger logger = LoggerFactory.getLogger(Generator.class);
  private static final String GENERATED_VALUE = "Autogenerated by JAX-DB Compiler (" + Generator.class.getPackage().getImplementationVersion() + ")";
  private static final String GENERATED_DATE = LocalDate.now().toString();
  private static final String HEADER_COMMENT;

  static {
    final StringBuilder out = new StringBuilder();
    out.append("/* ").append(GENERATED_VALUE).append('\n');
    out.append(" * THIS FILE SHOULD NOT BE EDITED */\n");
    HEADER_COMMENT = out.toString();
  }

  private final JSqlAudit audit;

  public Generator(final URL url) throws IOException, SAXException {
    this.audit = new JSqlAudit(new DDLxAudit((xLygluGCXAA.Schema)Bindings.parse(url)));
  }

  private static String getDoc(final $Documented documented, final int depth, final char start, final char end) {
    final XMLSchema.yAA.$String documentation = documented.getDocumentation();
    if (documentation == null)
      return "";

    final String doc = documentation.text().trim();
    if (doc.length() == 0)
      return "";

    final String indent = Strings.repeat(" ", depth * 2);
    final StringBuilder out = new StringBuilder();
    if (start != '\0')
      out.append(start);

    out.append(indent).append("/** ").append(doc).append(" */");
    if (end != '\0')
      out.append(end);

    return out.toString();
  }

  public void generate(final String name, final File destDir) throws GeneratorExecutionException, IOException {
    logger.info("Generating jSQL: " + name);

    final String pkg = type.class.getPackage().getName();

    final File dir = new File(destDir, pkg.replace('.', '/'));
    if (!dir.exists() && !dir.mkdirs())
      throw new IOException("Unable to create output dir: " + dir.getAbsolutePath());

    final String classSimpleName = Identifiers.toInstanceCase(name);

    final StringBuilder out = new StringBuilder(HEADER_COMMENT);
    out.append("package ").append(pkg).append(";\n\n");
    out.append(getDoc(audit.schema(), 0, '\0', '\n'));
    out.append('@').append(SuppressWarnings.class.getName()).append("(\"all\")\n");
    out.append('@').append(Generated.class.getName()).append("(value=\"").append(GENERATED_VALUE).append("\", date=\"").append(GENERATED_DATE).append("\")\n");
    out.append("public final class ").append(classSimpleName).append(" extends ").append(Schema.class.getCanonicalName()).append(" {\n");
    out.append("  private static final ").append(ThreadLocal.class.getName()).append("<LocalContext> localContext = new ").append(ThreadLocal.class.getName()).append("<LocalContext>() {\n");
    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    protected LocalContext initialValue() {\n");
    out.append("      return new LocalContext();\n");
    out.append("    }\n  };\n\n");

    out.append("  private static final class LocalContext {");
    for (final $Table table : audit.schema().getTable()) {
      if (!table.getAbstract$().text()) {
        final String entityName = Identifiers.toClassCase(table.getName$().text());
        final String instanceName = Identifiers.toInstanceCase(table.getName$().text());
        out.append("\n    private ").append(entityName).append(" $").append(instanceName).append(";");
        out.append("\n    private ").append(IdentityHashMap.class.getName()).append("<").append(Integer.class.getName()).append(",").append(entityName).append("> $").append(instanceName).append("s;");
      }
    }
    out.append("\n  }\n\n");

    // First create the abstract entities
    Iterator<$Table> iterator = audit.schema().getTable().iterator();
    for (int i = 0; iterator.hasNext(); ++i) {
      final $Table table = iterator.next();
      if (table.getAbstract$().text()) {
        if (i > 0)
          out.append("\n\n");

        out.append(makeTable(table));
      }
    }

    // Then, in proper inheritance order, the real entities
    iterator = audit.schema().getTable().iterator();
    for (int i = 0; iterator.hasNext(); ++i) {
      final $Table table = iterator.next();
      if (!table.getAbstract$().text()) {
        if (i > 0)
          out.append("\n\n");

        out.append(makeTable(table));
      }
    }

    out.append("\n\n");

    /*out.append("  private " + Classes.getFormalName(String.class) + " name = \"" + classSimpleName + "\";\n\n";
    out.append("  public boolean equals(final " + Classes.getFormalName(Object.class) + " obj) {\n";
    out.append("    if (obj == this)\n      return true;\n\n";
    out.append("    if (!(obj instanceof " + className + "))\n      return false;\n\n";
    out.append("    return name.equals(((" + className + ")obj).name);\n  }\n\n";
    out.append("  public int hashCode() {\n    return name.hashCode();\n  }\n\n";*/

    out.append("  private ").append(classSimpleName).append("() {\n  }\n}");

    final File javaFile = new File(dir, classSimpleName + ".java");
    Files.write(javaFile.toPath(), out.toString().getBytes());
  }

  private static final Object THIS = new Object();
  private static final Object MUTABLE = new Object();

  private Type getType(final xLygluGCXAA.$Table table, final $Column column) throws GeneratorExecutionException {
    final Class<?> cls = column.getClass().getSuperclass();
    GenerateOn<?> generateOnInsert = null;
    GenerateOn<?> generateOnUpdate = null;
    final Object[] params = {THIS, MUTABLE, column.getName$().text(), audit.isUnique(table, column), audit.isPrimary(table, column), column.getNull$().text()};
    if (column instanceof $Char) {
      final $Char type = ($Char)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Char.GenerateOnInsert$.UUID.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.UUID;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      return new Type(column, type.CHAR.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getLength$() == null ? null : type.getLength$().text(), type.getVarying$().text());
    }

    if (column instanceof $Clob) {
      final $Clob type = ($Clob)column;
      return new Type(column, type.CLOB.class, params, null, generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getLength$() == null ? null : type.getLength$().text());
    }

    if (column instanceof $Binary) {
      final $Binary type = ($Binary)column;
      return new Type(column, type.BINARY.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getLength$() == null ? null : type.getLength$().text(), type.getVarying$().text());
    }

    if (column instanceof $Blob) {
      final $Blob type = ($Blob)column;
      return new Type(column, type.BLOB.class, params, null, generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getLength$() == null ? null : type.getLength$().text());
    }

    if (column instanceof $Integer) {
      final $Integer integerColumn = ($Integer)column;
      if (integerColumn.getGenerateOnInsert$() != null) {
        if ($Integer.GenerateOnInsert$.AUTO_5FINCREMENT.text().equals(integerColumn.getGenerateOnInsert$().text())) {
          generateOnInsert = GenerateOn.AUTO_GENERATED;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + integerColumn.getGenerateOnInsert$().text());
        }
      }

      if (column instanceof $Tinyint) {
        final $Tinyint integer = ($Tinyint)column;
        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if ($Tinyint.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (audit.isPrimary(table, column))
              throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(column, type.TINYINT.class, params, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, integer.getJsqlKeyForUpdate$() != null && integer.getJsqlKeyForUpdate$().text(), integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }

      if (column instanceof $Smallint) {
        final $Smallint integer = ($Smallint)column;
        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if ($Smallint.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (audit.isPrimary(table, column))
              throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(column, type.SMALLINT.class, params, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, integer.getJsqlKeyForUpdate$() != null && integer.getJsqlKeyForUpdate$().text(), integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }

      if (column instanceof $Int) {
        final $Int integer = ($Int)column;
        if (integer.getSqlxGenerateOnInsert$() != null) {
          if (generateOnInsert != null)
            throw new GeneratorExecutionException("ddlx:generateOnInsert and sqlx:generateOnInsert are mutually exclusive");

          if ($Int.GenerateOnInsert$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnInsert = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Int.GenerateOnInsert$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnInsert = GenerateOn.EPOCH_SECONDS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + integer.getSqlxGenerateOnInsert$().text());
          }
        }

        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if (audit.isPrimary(table, column))
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          if ($Int.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else if ($Int.GenerateOnUpdate$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnUpdate = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Int.GenerateOnUpdate$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnUpdate = GenerateOn.EPOCH_SECONDS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(column, type.INT.class, params, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, integer.getJsqlKeyForUpdate$() != null && integer.getJsqlKeyForUpdate$().text(), integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }

      if (column instanceof $Bigint) {
        final $Bigint integer = ($Bigint)column;
        if (integer.getSqlxGenerateOnInsert$() != null) {
          if (generateOnInsert != null)
            throw new GeneratorExecutionException("ddlx:generateOnInsert and sqlx:generateOnInsert are mutually exclusive");

          if ($Bigint.GenerateOnInsert$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnInsert = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Bigint.GenerateOnInsert$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnInsert = GenerateOn.EPOCH_SECONDS;
          }
          else if ($Bigint.GenerateOnInsert$.EPOCH_5FMILLIS.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 13)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 13 for EPOCH_MILLIS");

            generateOnInsert = GenerateOn.EPOCH_MILLIS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + integer.getSqlxGenerateOnInsert$().text());
          }
        }

        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if (audit.isPrimary(table, column))
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          if ($Bigint.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else if ($Bigint.GenerateOnUpdate$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnUpdate = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Bigint.GenerateOnUpdate$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnUpdate = GenerateOn.EPOCH_SECONDS;
          }
          else if ($Bigint.GenerateOnUpdate$.EPOCH_5FMILLIS.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 13)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 13 for EPOCH_MILLIS");

            generateOnUpdate = GenerateOn.EPOCH_MILLIS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(column, type.BIGINT.class, params, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, integer.getJsqlKeyForUpdate$() != null && integer.getJsqlKeyForUpdate$().text(), integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }
    }

    if (column instanceof $Float) {
      final $Float type = ($Float)column;
      final Class<? extends type.DataType<?>> dataType = type.FLOAT.class;
      final Number min = type.getMin$() != null ? type.getMin$().text() : null;
      final Number max = type.getMax$() != null ? type.getMax$().text() : null;
      return new Type(column, dataType, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), min, max);
    }

    if (column instanceof $Double) {
      final $Double type = ($Double)column;
      final Class<? extends type.DataType<?>> dataType = type.DOUBLE.class;
      final Number min = type.getMin$() != null ? type.getMin$().text() : null;
      final Number max = type.getMax$() != null ? type.getMax$().text() : null;
      return new Type(column, dataType, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), min, max);
    }

    if (column instanceof $Decimal) {
      final $Decimal type = ($Decimal)column;
      return new Type(column, type.DECIMAL.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getPrecision$() == null ? null : type.getPrecision$().text().intValue(), type.getScale$() == null ? null : type.getScale$().text().intValue(), type.getMin$() == null ? null : type.getMin$().text(), type.getMax$() == null ? null : type.getMax$().text());
    }

    if (column instanceof $Date) {
      final $Date type = ($Date)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Date.GenerateOnInsert$.TIMESTAMP.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.TIMESTAMP;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      if (type.getSqlxGenerateOnUpdate$() != null) {
        if ($Date.GenerateOnUpdate$.TIMESTAMP.text().equals(type.getSqlxGenerateOnUpdate$().text())) {
          if (audit.isPrimary(table, column))
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          generateOnUpdate = GenerateOn.TIMESTAMP;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + type.getSqlxGenerateOnUpdate$().text());
        }
      }

      return new Type(column, type.DATE.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text());
    }

    if (column instanceof $Time) {
      final $Time type = ($Time)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Time.GenerateOnInsert$.TIMESTAMP.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.TIMESTAMP;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      if (type.getSqlxGenerateOnUpdate$() != null) {
        if ($Time.GenerateOnUpdate$.TIMESTAMP.text().equals(type.getSqlxGenerateOnUpdate$().text())) {
          if (audit.isPrimary(table, column))
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          generateOnUpdate = GenerateOn.TIMESTAMP;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + type.getSqlxGenerateOnUpdate$().text());
        }
      }

      return new Type(column, type.TIME.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getPrecision$().text());
    }

    if (column instanceof $Datetime) {
      final $Datetime type = ($Datetime)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Datetime.GenerateOnInsert$.TIMESTAMP.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.TIMESTAMP;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      if (type.getSqlxGenerateOnUpdate$() != null) {
        if ($Datetime.GenerateOnUpdate$.TIMESTAMP.text().equals(type.getSqlxGenerateOnUpdate$().text())) {
          if (audit.isPrimary(table, column))
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          generateOnUpdate = GenerateOn.TIMESTAMP;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + type.getSqlxGenerateOnUpdate$().text());
        }
      }

      return new Type(column, type.DATETIME.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text(), type.getPrecision$().text());
    }

    if (column instanceof $Boolean) {
      final $Boolean type = ($Boolean)column;
      return new Type(column, type.BOOLEAN.class, params, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text());
    }

    if (column instanceof $Enum) {
      final $Enum type = ($Enum)column;
      return new Type(column, type.ENUM.class, params, type.getDefault$() == null ? null : Identifiers.toClassCase(column.getName$().text()) + "." + type.getDefault$().text(), generateOnInsert, generateOnUpdate, type.getJsqlKeyForUpdate$() != null && type.getJsqlKeyForUpdate$().text());
    }

    throw new IllegalArgumentException("Unknown type: " + cls);
  }

  private static final class Type {
    private final $Column column;
    @SuppressWarnings("rawtypes")
    public final Class<? extends type.DataType> type;
    private final Object[] commonParams;
    private final GenerateOn<?> generateOnInsert;
    private final GenerateOn<?> generateOnUpdate;
    private final boolean keyForUpdate;
    private final Object[] customParams;
    private final Object _default;

    @SuppressWarnings("rawtypes")
    private Type(final $Column column, final Class<? extends type.DataType> type, final Object[] commonParams, final Object _default, final GenerateOn<?> generateOnInsert, final GenerateOn<?> generateOnUpdate, final boolean keyForUpdate, final Object ... params) {
      this.column = column;
      this.type = type;
      this.commonParams = commonParams;
      this._default = "null".equals(_default) ? null : _default;
      this.generateOnInsert = generateOnInsert;
      this.generateOnUpdate = generateOnUpdate;
      this.keyForUpdate = keyForUpdate;
      this.customParams = params;
    }

    private String compileParams() {
      final StringBuilder out = new StringBuilder();
      for (final Object param : commonParams)
        out.append(param == THIS ? "this" : param == MUTABLE ? "_mutable$" : GeneratorUtil.compile(param)).append(", ");

      out.append(GeneratorUtil.compile(_default)).append(", ");
      out.append(GeneratorUtil.compile(generateOnInsert)).append(", ");
      out.append(GeneratorUtil.compile(generateOnUpdate)).append(", ");
      out.append(keyForUpdate).append(", ");
      if (customParams != null)
        for (final Object param : customParams)
          out.append((param == THIS ? "this" : GeneratorUtil.compile(param))).append(", ");

      out.setLength(out.length() - 2);
      return out.toString();
    }

    public String getType(final boolean withGeneric) {
      final StringBuilder out = new StringBuilder(type.getCanonicalName());
      if (type != type.ENUM.class)
        return out.toString();

      out.append('<');
      if (withGeneric)
        out.append(Identifiers.toClassCase(column.getName$().text()));

      out.append('>');
      return out.toString();
    }

    @Override
    public String toString() {
      final StringBuilder builder = new StringBuilder("new ");
      builder.append(getType(false));
      builder.append('(');
      builder.append(compileParams());
      if (type == type.ENUM.class) {
        final String enumClass = Identifiers.toClassCase(column.getName$().text());
        builder.append(", ").append(enumClass).append(".class");
        builder.append(", ").append(enumClass).append("::fromString");
      }

      builder.append(')');
      return builder.toString();
    }
  }

  private int getColumnCount(xLygluGCXAA.$Table table, final boolean deep) {
    int count = 0;
    do {
      count += table.getColumn() != null ? table.getColumn().size() : 0;
    }
    while (deep && table.getExtends$() != null && (table = audit.tableNameToTable.get(table.getExtends$().text())) != null);
    return count;
  }

  private int getPrimaryColumnCount(xLygluGCXAA.$Table table, final boolean deep) {
    int count = 0;
    do {
      if (table.getConstraints() != null && table.getConstraints().getPrimaryKey() != null)
        count += table.getConstraints().getPrimaryKey().getColumn().size();
    }
    while (deep && table.getExtends$() != null && (table = audit.tableNameToTable.get(table.getExtends$().text())) != null);
    return count;
  }

  private int getAutoColumnCount(xLygluGCXAA.$Table table, final boolean deep) {
    int count = 0;
    do {
      if (table.getColumn() != null)
        for (final $Column column : table.getColumn())
          if (org.jaxdb.ddlx.Generator.isAuto(column))
            ++count;
    }
    while (deep && table.getExtends$() != null && (table = audit.tableNameToTable.get(table.getExtends$().text())) != null);
    return count;
  }

  public String makeTable(final $Table table) throws GeneratorExecutionException {
    final String ext = table.getExtends$() != null ? Identifiers.toClassCase(table.getExtends$().text()) : type.Table.class.getCanonicalName();
    final StringBuilder out = new StringBuilder();
    String abs = "";
    if (table.getAbstract$().text())
      abs = table.getAbstract$().text() ? " abstract" : "";

    final String entityName = Identifiers.toClassCase(table.getName$().text());
    final int totalColumnCount = getColumnCount(table, true);
    final int totalPrimaryCount = getPrimaryColumnCount(table, true);
    final int localPrimaryCount = getPrimaryColumnCount(table, false);
    final int totalAutoCount = getAutoColumnCount(table, true);
    final int localAutoCount = getAutoColumnCount(table, false);
    final List<$Column> columns = table.getColumn();
    if (!table.getAbstract$().text()) {
      final String instanceName = Identifiers.toInstanceCase(table.getName$().text());
      out.append("  public static ").append(entityName).append(' ').append(entityName).append("() {\n");
      out.append("    final LocalContext context = localContext.get();\n");
      out.append("    return context.$").append(instanceName).append(" == null ? context.$").append(instanceName).append(" = new ").append(entityName).append("(true, false) : context.$").append(instanceName).append(";\n");
      out.append("  }\n\n");
      out.append("  public static ").append(entityName).append(' ').append(entityName).append("(final int i) {\n");
      out.append("    ").append(entityName).append(" value;\n");
      out.append("    final LocalContext context = localContext.get();\n");
      out.append("    if (context.$").append(instanceName).append("s == null) {\n");
      out.append("      (context.$").append(instanceName).append("s = new ").append(IdentityHashMap.class.getName()).append("<>(2)).put(i, value = new ").append(entityName).append("(true, false));\n");
      out.append("      return value;\n");
      out.append("    }\n\n");
      out.append("    if ((value = context.$").append(instanceName).append("s.get(i)) == null)\n");
      out.append("      context.$").append(instanceName).append("s.put(i, value = new ").append(entityName).append("(true, false));\n\n");
      out.append("    return value;\n");
      out.append("  }\n\n");
    }

    out.append(getDoc(table, 1, '\0', '\n'));
    out.append("  public static").append(abs).append(" class ").append(entityName).append(" extends ").append(ext).append(" {\n");
    // FIXME: Gotta redesign this... right now, extended classes will all have their own copies of column and primary arrays
    if (!table.getAbstract$().text()) {
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    ").append(String.class.getName()).append(" name() {\n");
      out.append("      return \"").append(table.getName$().text()).append("\";\n");
      out.append("    }\n\n");
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    ").append(entityName).append(" newInstance() {\n");
      out.append("      return new ").append(entityName).append("(true, true);\n");
      out.append("    }\n\n");
      out.append("    /** Creates a new {@code ").append(entityName).append("}. */\n");
      out.append("    public ").append(entityName).append("() {\n");
      out.append("      this(true, false, new ").append(type.DataType.class.getCanonicalName()).append("[").append(totalColumnCount).append("], new ").append(type.DataType.class.getCanonicalName()).append("[").append(totalPrimaryCount).append("], new ").append(type.DataType.class.getCanonicalName()).append("[").append(totalAutoCount).append("]);\n");
      out.append("    }\n\n");
      out.append("    ").append(entityName).append("(final boolean _mutable$, final boolean _wasSelected$) {\n");
      out.append("      this(_mutable$, _wasSelected$, new ").append(type.DataType.class.getCanonicalName()).append("[").append(totalColumnCount).append("], new ").append(type.DataType.class.getCanonicalName()).append("[").append(totalPrimaryCount).append("], new ").append(type.DataType.class.getCanonicalName()).append("[").append(totalAutoCount).append("]);\n");
      out.append("    }\n\n");

      // Constructor with primary key columns
      final StringBuilder set = new StringBuilder();
      if (columns != null && totalPrimaryCount > 0) {
        out.append("    /** Creates a new {@code ").append(entityName).append("} with the specified primary key. */\n");
        out.append("    public ").append(entityName).append("(");
        xLygluGCXAA.$Table t = table;
        final StringBuilder params = new StringBuilder();
        do {
          final List<$Column> cs = t.getColumn();
          if (cs != null) {
            for (int i = 0, len = cs.size(); i < len; ++i) {
              final $Column column = cs.get(i);
              if (audit.isPrimary(table, column)) {
                params.append(makeParam(t, column)).append(", ");
                final String columnName = Identifiers.toCamelCase(column.getName$().text());
                set.append("      this.").append(columnName).append(".set(").append(columnName).append(");\n");
              }
            }
          }
        }
        while (t.getExtends$() != null && (t = audit.tableNameToTable.get(t.getExtends$().text())) != null);
        params.setLength(params.length() - 2);
        out.append(params).append(") {\n");
        out.append("      this();\n");
        set.setLength(set.length() - 1);
        out.append(set).append("\n    }\n\n");
      }

      // Copy constructor
      if (columns == null || columns.size() == 0)
        out.append("    @").append(SuppressWarnings.class.getName()).append("(\"unused\")\n");

      out.append("    /** Creates a new {@code ").append(entityName).append("} as a copy of the specified {@code ").append(entityName).append("} instance. */\n");
      out.append("    public ").append(entityName).append("(final ").append(entityName).append(" copy) {\n");
      out.append("      this();\n");
      if (columns != null) {
        for (int i = 0, len = columns.size(); i < len; ++i) {
          if (i > 0)
            out.append('\n');

          final $Column column = columns.get(i);
          final String columnName = Identifiers.toCamelCase(column.getName$().text());
          out.append("      this.").append(columnName).append(".set(copy.").append(columnName).append(".get());");
        }

        out.append('\n');
      }

      out.append("    }\n\n");
    }

    out.append("    ").append(entityName).append("(final boolean _mutable$, final boolean _wasSelected$, final ").append(type.DataType.class.getCanonicalName()).append("<?>[] _column$, final ").append(type.DataType.class.getCanonicalName()).append("<?>[] _primary$, final ").append(type.DataType.class.getCanonicalName()).append("<?>[] _auto$) {\n");
    out.append("      super(_mutable$, _wasSelected$, _column$, _primary$, _auto$);\n");

    int primaryIndex = 0;
    int autoIndex = 0;
    if (columns != null) {
      for (int i = 0, len = columns.size(); i < len; ++i) {
        if (i > 0)
          out.append('\n');

        final $Column column = columns.get(i);
        out.append("      _column$[").append((totalColumnCount - (columns.size() - i))).append("] = ");
        if (audit.isPrimary(table, column))
          out.append("_primary$[").append(totalPrimaryCount - (localPrimaryCount - primaryIndex++)).append("] = ");

        if (org.jaxdb.ddlx.Generator.isAuto(column))
          out.append("_auto$[").append(totalAutoCount - (localAutoCount - autoIndex++)).append("] = ");

        out.append(assignColumn(table, column));
      }

      out.append('\n');
    }

    out.append("    }\n");

    if (columns != null) {
      for (int i = 0, len = columns.size(); i < len; ++i) {
        final $Column column = columns.get(i);
        out.append(declareColumn(table, column));
      }

      out.append('\n');
    }

    if (table.getAbstract$().text()) {
      out.append('\n');
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public abstract ").append(entityName).append(" clone();\n");
    }
    else {
      out.append('\n');
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public ").append(entityName).append(" clone() {\n");
      out.append("      return new ").append(entityName).append("(this);\n");
      out.append("    }\n");
    }

    out.append('\n');
    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    public boolean equals(final ").append(Object.class.getName()).append(" obj) {\n");
    out.append("      if (obj == this)\n        return true;\n\n");
    out.append("      if (!(obj instanceof ").append(entityName).append(")").append((table.getExtends$() != null ? " || !super.equals(obj)" : "")).append(")\n        return false;\n\n");

    final List<$Column> primaryColumns = new ArrayList<>();
    final List<$Column> equalsColumns;
    if (columns != null) {
      for (final $Column column : columns)
        if (audit.isPrimary(table, column))
          primaryColumns.add(column);

      equalsColumns = primaryColumns.size() > 0 ? primaryColumns : columns;
      out.append("      final ").append(entityName).append(" that = (").append(entityName).append(")obj;");
      for (final $Column column : equalsColumns)
        out.append("\n      if (this.").append(Identifiers.toInstanceCase(column.getName$().text())).append(".get() != null ? !this.").append(Identifiers.toInstanceCase(column.getName$().text())).append(".get().equals(that.").append(Identifiers.toInstanceCase(column.getName$().text())).append(".get()) : that.").append(Identifiers.toInstanceCase(column.getName$().text())).append(".get() != null)\n        return false;\n");

      out.append("\n      return true;");
    }
    else {
      equalsColumns = null;
      out.append("      return true;");
    }
    out.append("\n    }");

    if (equalsColumns != null && equalsColumns.size() > 0) {
      out.append("\n\n");
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public int hashCode() {\n");
      out.append("      int hashCode = 1;");
      for (final $Column column : equalsColumns) {
        out.append("\n      if (").append(Identifiers.toInstanceCase(column.getName$().text())).append(".get() != null)");
        out.append("\n        hashCode = 31 * hashCode + this.").append(Identifiers.toInstanceCase(column.getName$().text())).append(".get().hashCode();\n");
      }
      out.append("\n      return hashCode;");
      out.append("\n    }");
    }

    out.append("\n\n");
    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    public ").append(String.class.getName()).append(" toString() {\n");
    out.append("      final ").append(StringBuilder.class.getName()).append(" builder = new ").append(StringBuilder.class.getName()).append("(super.toString());\n");
    out.append("      if (builder.charAt(builder.length() - 1) == '}')\n");
    out.append("        builder.setLength(builder.length() - 1);\n");
    out.append("      else\n");
    out.append("        builder.append(\" {\\n\");\n\n");

    if (columns != null)
      for (final $Column column : columns)
        out.append("      builder.append(\"  ").append(Identifiers.toInstanceCase(column.getName$().text())).append(": \").append(").append(Identifiers.toInstanceCase(column.getName$().text())).append(").append(\"\\n\");\n");

    out.append("      return builder.append('}').toString();");
    out.append("\n    }");
    out.append("\n  }");
    return out.toString();
  }

  public String makeParam(final xLygluGCXAA.$Table table, final $Column column) throws GeneratorExecutionException {
    final String columnName = Identifiers.toCamelCase(column.getName$().text());
    final Type type = getType(table, column);
    final String rawType;
    if (column instanceof $Enum)
      rawType = Identifiers.toClassCase(column.getName$().text());
    else
      rawType = ((Class<?>)Classes.getSuperclassGenericTypes(type.type)[0]).getCanonicalName();

    return "final " + rawType + " " + columnName;
  }

  private static final Map<Character,String> substitutions = Collections.singletonMap(' ', "_");

  public String declareColumn(final $Table table, final $Column column) throws GeneratorExecutionException {
    final String columnName = Identifiers.toCamelCase(column.getName$().text());
    final String typeName = Identifiers.toClassCase(column.getName$().text());
    final StringBuilder out = new StringBuilder();
    if (column instanceof $Enum) {
      out.append("\n    @").append(EntityEnum.Spec.class.getCanonicalName()).append("(table=\"").append(table.getName$().text()).append("\", column=\"").append(column.getName$().text()).append("\")");
      out.append("\n    public static enum ").append(typeName).append(" implements ").append(EntityEnum.class.getName()).append(" {");
      final StringBuilder enums = new StringBuilder();
      final List<String> values = Dialect.parseEnum((($Enum)column).getValues$().text());
      for (int i = 0, len = values.size(); i < len; ++i) {
        if (i > 0)
          enums.append(", ");

        final String value = values.get(i);
        enums.append(Identifiers.toIdentifier(value, substitutions).toUpperCase().replace(' ', '_')).append("(\"").append(value).append("\")");
      }

      out.append("\n      ").append(enums).append(";\n\n");
      out.append("      public static ").append(typeName).append(" fromString(final ").append(String.class.getName()).append(" string) {\n        if (string == null)\n          return null;\n\n        for (final ").append(typeName).append(" value : values())\n          if (string.equals(value.value))\n            return value;\n\n        return null;\n      }\n\n");
      out.append("      private final ").append(String.class.getName()).append(" value;\n\n      ").append(typeName).append("(final ").append(String.class.getName()).append(" value) {\n        this.value = value;\n      }\n\n");
      out.append("      @").append(Override.class.getName()).append("\n      public int length() {\n        return value.length();\n      }\n\n");
      out.append("      @").append(Override.class.getName()).append("\n      public char charAt(final int index) {\n        return value.charAt(index);\n      }\n\n");
      out.append("      @").append(Override.class.getName()).append("\n      public ").append(CharSequence.class.getName()).append(" subSequence(final int start, final int end) {\n        return value.subSequence(start, end);\n      }\n\n");
      out.append("      @").append(Override.class.getName()).append("\n      public ").append(String.class.getName()).append(" toString() {\n        return value;\n      }\n    }");
    }

    final Type type = getType(table, column);
    out.append(getDoc(column, 2, '\n', '\0'));
    return out.append("\n    public final ").append(type.getType(true)).append(' ').append(columnName).append(';').toString();
  }

  public String assignColumn(final $Table table, final $Column column) throws GeneratorExecutionException {
    final String columnName = Identifiers.toCamelCase(column.getName$().text());
    final StringBuilder out = new StringBuilder();

    final Type type = getType(table, column);
    return out.append(columnName).append(" = ").append(type).append(';').toString();
  }
}