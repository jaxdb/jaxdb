/* Copyright (c) 2014 JAX-DB
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * You should have received a copy of The MIT License (MIT) along with this
 * program. If not, see <http://opensource.org/licenses/MIT/>.
 */

package org.jaxdb.jsql.generator;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Generated;
import javax.xml.transform.TransformerException;

import org.jaxdb.ddlx.DDLx;
import org.jaxdb.ddlx.GeneratorExecutionException;
import org.jaxdb.jsql.EntityEnum;
import org.jaxdb.jsql.GenerateOn;
import org.jaxdb.jsql.Key;
import org.jaxdb.jsql.Schema;
import org.jaxdb.jsql.data;
import org.jaxdb.vendor.Dialect;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Bigint;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Binary;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Blob;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Boolean;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Char;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Clob;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Column;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Date;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Datetime;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Decimal;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Documented;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Double;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Enum;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Float;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Int;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Integer;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Named;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Schema.Table;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Smallint;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Time;
import org.jaxdb.www.ddlx_0_5.xLygluGCXAA.$Tinyint;
import org.libj.lang.Classes;
import org.libj.lang.Identifiers;
import org.libj.lang.Strings;
import org.libj.net.URLs;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3.www._2001.XMLSchema;
import org.w3.www._2001.XMLSchema.yAA;
import org.xml.sax.SAXException;

public class Generator {
  private static final Logger logger = LoggerFactory.getLogger(Generator.class);
  private static final String GENERATED_VALUE = "Autogenerated by JAX-DB Compiler (" + Generator.class.getPackage().getImplementationVersion() + ")";
  private static final String GENERATED_DATE = LocalDate.now().toString();
  private static final String HEADER_COMMENT;

  static {
    final StringBuilder out = new StringBuilder();
    out.append("/* ").append(GENERATED_VALUE).append('\n');
    out.append(" * THIS FILE SHOULD NOT BE EDITED */\n");
    HEADER_COMMENT = out.toString();
  }

  private static final Map<Character,String> substitutions = Collections.singletonMap(' ', "_");

  private static String enumStringToEnum(final String value) {
    return Identifiers.toIdentifier(value, substitutions).toUpperCase().replace(' ', '_');
  }

  public static void main(final String[] args) throws GeneratorExecutionException, IOException, SAXException, TransformerException {
    generate(URLs.create(args[0]), args[1], new File(args[2]));
  }

  public static void generate(final URL url, final String name, final File destDir) throws GeneratorExecutionException, IOException, SAXException, TransformerException {
    new Generator(url, name, destDir).generate();
  }

  private final DDLx ddlx;
  private final String name;
  private final File destDir;

  private final String packageName;
  private final String schemaClassName;
  private final String schemaClassSimpleName;

  private Generator(final URL url, final String name, final File destDir) throws IOException, SAXException, TransformerException {
    this.ddlx = new DDLx(url);
    this.name = name;
    this.destDir = destDir;

    this.packageName = data.class.getPackage().getName();
    this.schemaClassSimpleName = Identifiers.toInstanceCase(name);
    this.schemaClassName = packageName + "." + schemaClassSimpleName;
  }

  private static final Comparator<$Named> namedComparator = (o1, o2) -> o1.getName$().text().compareTo(o2.getName$().text());

  private void generate() throws GeneratorExecutionException, IOException {
    if (logger.isInfoEnabled())
      logger.info("Generating jSQL: " + name);

    final File dir = new File(destDir, packageName.replace('.', '/'));
    if (!dir.exists() && !dir.mkdirs())
      throw new IOException("Unable to create output dir: " + dir.getAbsolutePath());

    final StringBuilder out = new StringBuilder(HEADER_COMMENT);
    out.append("package ").append(packageName).append(";\n\n");
    out.append(getDoc(ddlx.getNormalizedSchema(), 0, '\0', '\n'));
    out.append('@').append(SuppressWarnings.class.getName()).append("(\"all\")\n");
    out.append('@').append(Generated.class.getName()).append("(value=\"").append(GENERATED_VALUE).append("\", date=\"").append(GENERATED_DATE).append("\")\n");
    out.append("public final class ").append(schemaClassSimpleName).append(" extends ").append(Schema.class.getCanonicalName()).append(" {");
    final List<Table> tables = ddlx.getNormalizedSchema().getTable();

    final Map<String,Table> tableNameToTable = new HashMap<>();
    for (final Table table : tables)
      tableNameToTable.put(table.getName$().text(), table);

    final List<$Column> templates = ddlx.getNormalizedSchema().getTemplate();
    if (templates != null)
      for (final $Column template : templates)
        if (template instanceof $Enum)
          out.append(declareEnumClass(schemaClassName, ($Enum)template, 2)).append('\n');

    // First create the abstract entities
    for (final Table table : tables)
      if (table.getAbstract$().text())
        out.append(makeTable(table, tableNameToTable)).append('\n');

    // Then, in proper inheritance order, the real entities
    final List<Table> sortedTables = new ArrayList<>();
    for (final Table table : tables) {
      if (!table.getAbstract$().text()) {
        sortedTables.add(table);
        out.append(makeTable(table, tableNameToTable)).append('\n');
      }
    }

    sortedTables.sort(namedComparator);
    out.append("\n  private static final ").append(String.class.getName()).append("[] names = {");
    for (final Table table : sortedTables)
      out.append("\"").append(table.getName$().text()).append("\", ");

    out.setCharAt(out.length() - 2, '}');
    out.setCharAt(out.length() - 1, ';');
    out.append("\n  private static final ").append(data.Table.class.getCanonicalName()).append("<?>[] tables = {");
    for (final Table table : sortedTables)
      getClassNameOfTable(out, table).append("(), ");

    out.setCharAt(out.length() - 2, '}');
    out.setCharAt(out.length() - 1, ';');
    out.append('\n');

    out.append("\n  public static ").append(data.Table.class.getCanonicalName()).append("<?> getTable(final ").append(String.class.getName()).append(" name) {");
    out.append("\n    final int index = ").append(Arrays.class.getName()).append(".binarySearch(names, name);");
    out.append("\n    return index < 0 ? null : tables[index];");
    out.append("\n  }\n");

//    out.append("\n  private static ").append(TableCache.class.getName()).append(" cache;\n");
//    out.append("\n  public static ").append(TableCache.class.getName()).append(" getRowCache() {");
//    out.append("\n    return cache;");
//    out.append("\n  }\n");
//    out.append("\n  public static void setRowCache(").append(TableCache.class.getName()).append(" cache) {");
//    out.append("\n    ").append(schemaClassSimpleName).append(".cache = cache;");
//    out.append("\n  }\n");

    out.append("\n  private ").append(schemaClassSimpleName).append("() {\n");
    out.append("  }\n}");

    final File javaFile = new File(dir, schemaClassSimpleName + ".java");
    Files.write(javaFile.toPath(), out.toString().getBytes());
  }

  private static String getDoc(final $Documented documented, final int depth, final char start, final char end) {
    final XMLSchema.yAA.$String documentation = documented.getDocumentation();
    if (documentation == null)
      return "";

    final String doc = documentation.text().trim();
    if (doc.length() == 0)
      return "";

    final String indent = Strings.repeat(" ", depth * 2);
    final StringBuilder out = new StringBuilder();
    if (start != '\0')
      out.append(start);

    out.append(indent).append("/** ").append(doc).append(" */");
    if (end != '\0')
      out.append(end);

    return out.toString();
  }

  private static String declareEnumClass(final String containerClassName, final $Enum column, final int spaces) {
    final String classSimpleName = Identifiers.toClassCase(column.getName$().text());
    final String className = containerClassName + "." + classSimpleName;
    final List<String> names = Dialect.parseEnum(column.getValues$().text());
    final StringBuilder out = new StringBuilder();
    final String s = Strings.repeat(' ', spaces);
    out.append('\n').append(s).append('@').append(EntityEnum.Type.class.getCanonicalName()).append("(\"").append(Dialect.getTypeName(column)).append("\")");
    out.append('\n').append(s).append("public static final class ").append(classSimpleName).append(" implements ").append(EntityEnum.class.getName()).append(" {");
    out.append('\n').append(s).append("  private static byte index = 0;");
    out.append('\n').append(s).append("  public static final ").append(className);
    for (int i = 0, len = names.size(); i < len; ++i) {
      out.append(' ').append(enumStringToEnum(names.get(i))).append(',');
    }

    out.setCharAt(out.length() - 1, ';');
    out.append('\n').append(s).append("  private static final ").append(className).append("[] values = {");
    for (int i = 0, len = names.size(); i < len; ++i) {
      final String name = names.get(i);
      out.append(enumStringToEnum(name)).append(" = new ").append(className).append("(\"").append(name).append("\"), ");
    }

    out.setCharAt(out.length() - 2, '}');
    out.setCharAt(out.length() - 1, ';');
    out.append("\n\n").append(s).append("  public static ").append(className).append("[] values() {");
    out.append('\n').append(s).append("    return values;");
    out.append('\n').append(s).append("  }\n");
    out.append('\n').append(s).append("  public static ").append(className).append(" valueOf(final ").append(String.class.getName()).append(" string) {");
    out.append('\n').append(s).append("    if (string == null)");
    out.append('\n').append(s).append("      return null;\n");
    out.append('\n').append(s).append("    for (final ").append(className).append(" value : values())");
    out.append('\n').append(s).append("      if (string.equals(value.name))");
    out.append('\n').append(s).append("        return value;\n");
    out.append('\n').append(s).append("    return null;");
    out.append('\n').append(s).append("  }\n");
    out.append('\n').append(s).append("  private final byte ordinal;");
    out.append('\n').append(s).append("  private final ").append(String.class.getName()).append(" name;\n");
    out.append('\n').append(s).append("  private ").append(classSimpleName).append("(final ").append(String.class.getName()).append(" name) {");
    out.append('\n').append(s).append("    this.ordinal = index++;");
    out.append('\n').append(s).append("    this.name = name;");
    out.append('\n').append(s).append("  }\n");
    out.append('\n').append(s).append("  public byte ordinal() {");
    out.append('\n').append(s).append("    return ordinal;");
    out.append('\n').append(s).append("  }\n");

    out.append('\n').append(s).append("  @").append(Override.class.getName()).append('\n').append(s).append("  public ").append(String.class.getName()).append(" toString() {\n").append(s).append("    return name;\n").append(s).append("  }\n").append(s).append("}");

    return out.toString();
  }

  private static final Object THIS = new Object();
  private static final Object MUTABLE = new Object();

  private static boolean isNull(final $Column column) {
    return column.getNull$() == null || column.getNull$().text();
  }

  private static boolean isVarying(final yAA.$Boolean varying) {
    return varying != null && varying.text();
  }

  private Type getType(final Table table, final $Column column) throws GeneratorExecutionException {
    final String columnName = column.getName$().text();
    boolean isKeyForUpdate = false;
    // FIXME: Make efficient
    if (table.getJsqlKeyForUpdate() != null)
      for (final xLygluGCXAA.$Named col : table.getJsqlKeyForUpdate().getColumn())
        if (isKeyForUpdate = columnName.equals(col.getName$().text()))
          break;

    final Class<?> cls = column.getClass().getSuperclass();
    GenerateOn<?> generateOnInsert = null;
    GenerateOn<?> generateOnUpdate = null;
    final boolean isPrimary = ddlx.isPrimary(table, column);
    final Object[] commonParams = {THIS, MUTABLE, "\"" + column.getName$().text() + "\"", ddlx.isUnique(table, column), isPrimary, isNull(column)};
    if (column instanceof $Char) {
      final $Char type = ($Char)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Char.GenerateOnInsert$.UUID.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.UUID;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      return new Type(table, column, isPrimary, data.CHAR.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getLength$() == null ? null : type.getLength$().text(), isVarying(type.getVarying$()));
    }

    if (column instanceof $Clob) {
      final $Clob type = ($Clob)column;
      return new Type(table, column, isPrimary, data.CLOB.class, commonParams, null, generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getLength$() == null ? null : type.getLength$().text());
    }

    if (column instanceof $Binary) {
      final $Binary type = ($Binary)column;
      return new Type(table, column, isPrimary, data.BINARY.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getLength$() == null ? null : type.getLength$().text(), isVarying(type.getVarying$()));
    }

    if (column instanceof $Blob) {
      final $Blob type = ($Blob)column;
      return new Type(table, column, isPrimary, data.BLOB.class, commonParams, null, generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getLength$() == null ? null : type.getLength$().text());
    }

    if (column instanceof $Integer) {
      final $Integer integerColumn = ($Integer)column;
      if (integerColumn.getGenerateOnInsert$() != null) {
        if ($Integer.GenerateOnInsert$.AUTO_5FINCREMENT.text().equals(integerColumn.getGenerateOnInsert$().text())) {
          generateOnInsert = GenerateOn.AUTO_GENERATED;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + integerColumn.getGenerateOnInsert$().text());
        }
      }

      if (column instanceof $Tinyint) {
        final $Tinyint integer = ($Tinyint)column;
        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if ($Tinyint.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (isPrimary)
              throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(table, column, isPrimary, data.TINYINT.class, commonParams, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }

      if (column instanceof $Smallint) {
        final $Smallint integer = ($Smallint)column;
        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if ($Smallint.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (isPrimary)
              throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(table, column, isPrimary, data.SMALLINT.class, commonParams, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }

      if (column instanceof $Int) {
        final $Int integer = ($Int)column;
        if (integer.getSqlxGenerateOnInsert$() != null) {
          if (generateOnInsert != null)
            throw new GeneratorExecutionException("ddlx:generateOnInsert and sqlx:generateOnInsert are mutually exclusive");

          if ($Int.GenerateOnInsert$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnInsert = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Int.GenerateOnInsert$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnInsert = GenerateOn.EPOCH_SECONDS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + integer.getSqlxGenerateOnInsert$().text());
          }
        }

        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if (isPrimary)
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          if ($Int.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else if ($Int.GenerateOnUpdate$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnUpdate = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Int.GenerateOnUpdate$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("INT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnUpdate = GenerateOn.EPOCH_SECONDS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(table, column, isPrimary, data.INT.class, commonParams, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }

      if (column instanceof $Bigint) {
        final $Bigint integer = ($Bigint)column;
        if (integer.getSqlxGenerateOnInsert$() != null) {
          if (generateOnInsert != null)
            throw new GeneratorExecutionException("ddlx:generateOnInsert and sqlx:generateOnInsert are mutually exclusive");

          if ($Bigint.GenerateOnInsert$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnInsert = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Bigint.GenerateOnInsert$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnInsert = GenerateOn.EPOCH_SECONDS;
          }
          else if ($Bigint.GenerateOnInsert$.EPOCH_5FMILLIS.text().equals(integer.getSqlxGenerateOnInsert$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 13)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 13 for EPOCH_MILLIS");

            generateOnInsert = GenerateOn.EPOCH_MILLIS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + integer.getSqlxGenerateOnInsert$().text());
          }
        }

        if (integer.getSqlxGenerateOnUpdate$() != null) {
          if (isPrimary)
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          if ($Bigint.GenerateOnUpdate$.INCREMENT.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            generateOnUpdate = GenerateOn.INCREMENT;
          }
          else if ($Bigint.GenerateOnUpdate$.EPOCH_5FMINUTES.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 8)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 8 for EPOCH_MINUTES");

            generateOnUpdate = GenerateOn.EPOCH_MINUTES;
          }
          else if ($Bigint.GenerateOnUpdate$.EPOCH_5FSECONDS.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 10)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 10 for EPOCH_SECONDS");

            generateOnUpdate = GenerateOn.EPOCH_SECONDS;
          }
          else if ($Bigint.GenerateOnUpdate$.EPOCH_5FMILLIS.text().equals(integer.getSqlxGenerateOnUpdate$().text())) {
            if (integer.getPrecision$().text() != null && integer.getPrecision$().text() < 13)
              throw new GeneratorExecutionException("BIGINT(" + integer.getPrecision$().text() + ") requires minimum precision of 13 for EPOCH_MILLIS");

            generateOnUpdate = GenerateOn.EPOCH_MILLIS;
          }
          else {
            throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + integer.getSqlxGenerateOnUpdate$().text());
          }
        }

        return new Type(table, column, isPrimary, data.BIGINT.class, commonParams, integer.getDefault$() == null ? null : integer.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, integer.getPrecision$() == null ? null : integer.getPrecision$().text().intValue(), integer.getMin$() == null ? null : integer.getMin$().text(), integer.getMax$() == null ? null : integer.getMax$().text());
      }
    }

    if (column instanceof $Float) {
      final $Float type = ($Float)column;
      final Class<? extends data.Column<?>> col = data.FLOAT.class;
      final Number min = type.getMin$() != null ? type.getMin$().text() : null;
      final Number max = type.getMax$() != null ? type.getMax$().text() : null;
      return new Type(table, column, isPrimary, col, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, min, max);
    }

    if (column instanceof $Double) {
      final $Double type = ($Double)column;
      final Class<? extends data.Column<?>> col = data.DOUBLE.class;
      final Number min = type.getMin$() != null ? type.getMin$().text() : null;
      final Number max = type.getMax$() != null ? type.getMax$().text() : null;
      return new Type(table, column, isPrimary, col, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, min, max);
    }

    if (column instanceof $Decimal) {
      final $Decimal type = ($Decimal)column;
      return new Type(table, column, isPrimary, data.DECIMAL.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getPrecision$() == null ? null : type.getPrecision$().text().intValue(), type.getScale$() == null ? null : type.getScale$().text().intValue(), type.getMin$() == null ? null : type.getMin$().text(), type.getMax$() == null ? null : type.getMax$().text());
    }

    if (column instanceof $Date) {
      final $Date type = ($Date)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Date.GenerateOnInsert$.TIMESTAMP.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.TIMESTAMP;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      if (type.getSqlxGenerateOnUpdate$() != null) {
        if ($Date.GenerateOnUpdate$.TIMESTAMP.text().equals(type.getSqlxGenerateOnUpdate$().text())) {
          if (isPrimary)
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          generateOnUpdate = GenerateOn.TIMESTAMP;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + type.getSqlxGenerateOnUpdate$().text());
        }
      }

      return new Type(table, column, isPrimary, data.DATE.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate);
    }

    if (column instanceof $Time) {
      final $Time type = ($Time)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Time.GenerateOnInsert$.TIMESTAMP.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.TIMESTAMP;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      if (type.getSqlxGenerateOnUpdate$() != null) {
        if ($Time.GenerateOnUpdate$.TIMESTAMP.text().equals(type.getSqlxGenerateOnUpdate$().text())) {
          if (isPrimary)
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          generateOnUpdate = GenerateOn.TIMESTAMP;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + type.getSqlxGenerateOnUpdate$().text());
        }
      }

      return new Type(table, column, isPrimary, data.TIME.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getPrecision$() == null ? null : type.getPrecision$().text());
    }

    if (column instanceof $Datetime) {
      final $Datetime type = ($Datetime)column;
      if (type.getSqlxGenerateOnInsert$() != null) {
        if ($Datetime.GenerateOnInsert$.TIMESTAMP.text().equals(type.getSqlxGenerateOnInsert$().text()))
          generateOnInsert = GenerateOn.TIMESTAMP;
        else
          throw new GeneratorExecutionException("Unknown generateOnInsert specification: " + type.getSqlxGenerateOnInsert$().text());
      }

      if (type.getSqlxGenerateOnUpdate$() != null) {
        if ($Datetime.GenerateOnUpdate$.TIMESTAMP.text().equals(type.getSqlxGenerateOnUpdate$().text())) {
          if (isPrimary)
            throw new GeneratorExecutionException("Primary column cannot specify generateOnUpdate");

          generateOnUpdate = GenerateOn.TIMESTAMP;
        }
        else {
          throw new GeneratorExecutionException("Unknown generateOnUpdate specification: " + type.getSqlxGenerateOnUpdate$().text());
        }
      }

      return new Type(table, column, isPrimary, data.DATETIME.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate, type.getPrecision$() == null ? null : type.getPrecision$().text());
    }

    if (column instanceof $Boolean) {
      final $Boolean type = ($Boolean)column;
      return new Type(table, column, isPrimary, data.BOOLEAN.class, commonParams, type.getDefault$() == null ? null : type.getDefault$().text(), generateOnInsert, generateOnUpdate, isKeyForUpdate);
    }

    if (column instanceof $Enum) {
      final $Enum type = ($Enum)column;
      return new Type(table, column, isPrimary, data.ENUM.class, commonParams, type.getDefault$() == null ? null : getClassNameOfEnum(table, type).append('.').append(enumStringToEnum(type.getDefault$().text())), generateOnInsert, generateOnUpdate, isKeyForUpdate);
    }

    throw new IllegalArgumentException("Unknown type: " + cls);
  }

  private final class Type {
    private final Table table;
    private final $Column column;
    final boolean isPrimary;
    @SuppressWarnings("rawtypes")
    private final Class<? extends data.Column> type;
    private final Object[] commonParams;
    private final GenerateOn<?> generateOnInsert;
    private final GenerateOn<?> generateOnUpdate;
    private final boolean keyForUpdate;
    private final Object[] customParams;
    private final Object _default;
    private final String instanceCase;
    private final String camelCase;

    @SuppressWarnings("rawtypes")
    private Type(final Table table, final $Column column, final boolean isPrimary, final Class<? extends data.Column> type, final Object[] commonParams, final Object _default, final GenerateOn<?> generateOnInsert, final GenerateOn<?> generateOnUpdate, final boolean keyForUpdate, final Object ... params) {
      this.table = table;
      this.column = column;
      this.isPrimary = isPrimary;
      this.type = type;
      this.commonParams = commonParams;
      this._default = "null".equals(_default) ? null : _default;
      this.generateOnInsert = generateOnInsert;
      this.generateOnUpdate = generateOnUpdate;
      this.keyForUpdate = keyForUpdate;
      this.customParams = params;
      this.instanceCase = Identifiers.toInstanceCase(column.getName$().text());
      this.camelCase = Identifiers.toCamelCase(column.getName$().text());
    }

    private String compileParams() {
      final StringBuilder out = new StringBuilder();
      for (final Object param : commonParams)
        out.append(param == THIS ? "this" : param == MUTABLE ? "_mutable$" : param).append(", ");

      out.append(GeneratorUtil.compile(_default)).append(", ");
      out.append(GeneratorUtil.compile(generateOnInsert)).append(", ");
      out.append(GeneratorUtil.compile(generateOnUpdate)).append(", ");
      out.append(keyForUpdate).append(", ");
      if (customParams != null)
        for (final Object param : customParams)
          out.append(param == THIS ? "this" : GeneratorUtil.compile(param)).append(", ");

      out.setLength(out.length() - 2);
      return out.toString();
    }

    private String declareColumn() {
      final StringBuilder out = new StringBuilder();
      if (column instanceof $Enum) {
        final $Enum type = ($Enum)column;
        if (column.getTemplate$() == null)
          out.append(declareEnumClass(getClassNameOfTable(new StringBuilder(), table).toString(), type, 4));
      }

      out.append(getDoc(column, 2, '\n', '\0'));
      out.append("\n    public final ");
      return getCanonicalName(out, true).append(' ').append(camelCase).append(';').toString();
    }

    private void assignColumn(final StringBuilder out) {
      out.append(camelCase).append(" = ").append(toString()).append(';');
    }

    private StringBuilder getCanonicalName(final StringBuilder out, final boolean withGeneric) {
      out.append(type.getCanonicalName());
      if (type != data.ENUM.class)
        return out;

      out.append('<');
      if (withGeneric)
        out.append(getClassNameOfEnum(table, column));

      out.append('>');
      return out;
    }

    private String makeParam() {
      final String rawType;
      if (column instanceof $Enum)
        rawType = Identifiers.toClassCase(column.getName$().text());
      else
        rawType = ((Class<?>)Classes.getSuperclassGenericTypes(type)[0]).getCanonicalName();

      return "final " + rawType + " " + camelCase;
    }

    public String getInstanceName() {
      return instanceCase;
    }

    @Override
    public String toString() {
      final StringBuilder out = new StringBuilder("new ");
      getCanonicalName(out, false).append('(');
      out.append(compileParams());
      if (type == data.ENUM.class) {
        final StringBuilder enumClassName = getClassNameOfEnum(table, column);
        out.append(", ").append(enumClassName).append(".values()");
        out.append(", ").append(enumClassName).append("::valueOf");
      }

      return out.append(')').toString();
    }
  }

  private static int getPrimaryColumnCount(final Table table) {
    return table.getConstraints() == null || table.getConstraints().getPrimaryKey() == null ? 0 : table.getConstraints().getPrimaryKey().getColumn().size();
  }

  private static StringBuilder newColumnArray(final StringBuilder out, final int len) {
    return len == 0 ? out.append("empty") : out.append("new ").append(data.Column.class.getCanonicalName()).append('[').append(len).append(']');
  }

  private static class Count {
    private int count;
    private int offset;

    private void inc(final int c, final boolean off) {
      count += c;
      if (off)
        offset += c;
    }
  }

  private static class Info {
    private final Count totalPrimaryCount = new Count();
    private final Count totalAutoCount = new Count();
    private final Count totalKeyForUpdateCount = new Count();
    private String rootClassName;
  }

  private Type[] getTypes(final Table table, final Map<String,Table> tableNameToTable, final int depth, final Info info) throws GeneratorExecutionException {
    final List<$Column> columns = table.getColumn();
    final int size = columns == null ? 0 : columns.size();
    final Type[] types;
    if (table.getExtends$() == null) {
      types = new Type[depth + size];
      info.rootClassName = schemaClassName + "." + Identifiers.toClassCase(table.getName$().text());
    }
    else {
      types = getTypes(tableNameToTable.get(table.getExtends$().text()), tableNameToTable, depth + size, info);
    }

    if (columns != null) {
      final boolean isSuperTable = depth != 0;
      info.totalPrimaryCount.inc(getPrimaryColumnCount(table), isSuperTable);

      for (int c = 1; c <= size; ++c) {
        final $Column column = columns.get(size - c);
        final Type type = getType(table, column);

        if (org.jaxdb.ddlx.Generator.isAuto(column))
          info.totalAutoCount.inc(1, isSuperTable);

        if (type.keyForUpdate)
          info.totalKeyForUpdateCount.inc(1, isSuperTable);

        types[types.length - depth - c] = type;
      }
    }

    return types;
  }

  private String makeTable(final Table table, final Map<String,Table> tableNameToTable) throws GeneratorExecutionException {
    final String tableName = table.getName$().text();
    final Info info = new Info();
    final Type[] types = getTypes(table, tableNameToTable, 0, info);

    final int noColumnsLocal = table.getColumn() == null ? 0 : table.getColumn().size();
    final int noColumnsTotal = types.length;

    final String classSimpleName = Identifiers.toClassCase(tableName);
    final String className = schemaClassName + "." + classSimpleName;
    final String instanceName = Identifiers.toInstanceCase(tableName);

    final StringBuilder out = new StringBuilder();
    if (!table.getAbstract$().text()) {
      out.append("\n  private static final ").append(className).append(" $").append(instanceName).append(" = new ").append(className).append("(false, false);\n\n");
      out.append("  public static ").append(className).append(' ').append(classSimpleName).append("() {\n");
      out.append("    return $").append(instanceName).append(";\n");
      out.append("  }\n");
    }

    final String ext = table.getExtends$() == null ? data.Table.class.getCanonicalName() + "<" + className + ">" : Identifiers.toClassCase(table.getExtends$().text());

    final String abs = table.getAbstract$().text() ? " abstract" : "";
    out.append(getDoc(table, 1, '\0', '\n'));
    out.append("\n  public").append(abs).append(" static class ").append(classSimpleName).append(" extends ").append(ext).append(" {\n");
    // FIXME: Gotta redesign this... right now, extended classes will all have their own copies of column and primary arrays

    if (table.getExtends$() == null) {
      out.append("    private final ").append(Key.class.getName()).append('<').append(className).append("> _primaryKey$ = new ").append(Key.class.getName()).append("<>(this);\n\n");
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public final ").append(Key.class.getName()).append('<').append(className).append("> getKey() {\n");
      out.append("      return _primaryKey$;\n");
      out.append("    }\n\n");
    }

    if (!table.getAbstract$().text()) {
      out.append("    private static final ").append(String.class.getName()).append("[] _columnName$ = {");
      for (int i = 0; i < noColumnsTotal; ++i)
        types[i].column.text(String.valueOf(i)); // FIXME: Hacking this to record what is the index of each column

      final List<$Column> sortedColumns = new ArrayList<>();
      for (final Type type : types)
        sortedColumns.add(type.column);
      sortedColumns.sort(namedComparator);

      for (final $Column column : sortedColumns)
        out.append("\"").append(column.getName$().text()).append("\", ");
      out.setCharAt(out.length() - 2, '}');
      out.setCharAt(out.length() - 1, ';');
      out.append("\n");
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    ").append(String.class.getName()).append("[] _columnName$() {\n");
      out.append("      return _columnName$;\n");
      out.append("    }\n\n");

      out.append("    private static final byte[] _columnIndex$ = {");
      for (final $Column column : sortedColumns)
        out.append(column.text()).append(", ");
      out.setCharAt(out.length() - 2, '}');
      out.setCharAt(out.length() - 1, ';');
      out.append('\n');
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    byte[] _columnIndex$() {\n");
      out.append("      return _columnIndex$;\n");
      out.append("    }\n\n");

      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public ").append(String.class.getName()).append(" getName() {\n");
      out.append("      return \"").append(tableName).append("\";\n");
      out.append("    }\n\n");

      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    ").append(className).append(" newInstance() {\n");
      out.append("      return new ").append(className).append("(true, true);\n");
      out.append("    }\n\n");

      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    ").append(className).append(" immutable() {\n");
      out.append("      return $").append(instanceName).append(";\n");
      out.append("    }\n\n");

      final StringBuilder init = new StringBuilder();
      newColumnArray(init, noColumnsTotal).append(", ");
      newColumnArray(init, info.totalPrimaryCount.count).append(", ");
      newColumnArray(init, info.totalKeyForUpdateCount.count).append(", ");
      newColumnArray(init, info.totalAutoCount.count);

      out.append("    ").append(classSimpleName).append("(final boolean _mutable$, final boolean _wasSelected$) {\n");
      out.append("      this(_mutable$, _wasSelected$, ").append(init).append(", null, false);\n");
      out.append("    }\n\n");
      out.append("    /** Creates a new {@link ").append(className).append("}. */\n");
      out.append("    public ").append(classSimpleName).append("() {\n");
      out.append("      this(null, false);\n");
      out.append("    }\n\n");

      // Constructor with primary key columns
      final StringBuilder set = new StringBuilder();
      if (info.totalPrimaryCount.count > 0) {
        out.append("    /** Creates a new {@link ").append(className).append("} with the specified primary key. */\n");
        out.append("    public ").append(classSimpleName).append("(");
        final StringBuilder params = new StringBuilder();
        final StringBuilder superParams = new StringBuilder();
        for (final Type type : types) {
          if (type.isPrimary) {
            params.append(type.makeParam()).append(", ");
            final String fieldName = Identifiers.toCamelCase(type.column.getName$().text());
            if (type.table == table)
              set.append("      this.").append(fieldName).append(".set(").append(fieldName).append(");\n");
            else
              superParams.append(fieldName).append(", ");
          }
        }

        params.setLength(params.length() - 2);
        out.append(params).append(") {\n");
        if (superParams.length() == 0) {
          out.append("      this();\n");
        }
        else {
          superParams.setLength(superParams.length() - 2);
          out.append("      super(").append(superParams).append(");\n");
        }

        if (set.length() > 0) {
          set.setLength(set.length() - 1);
          out.append(set);
        }

        out.append("\n    }\n\n");
      }

      // Copy constructor
      out.append("    /** Creates a new {@link ").append(className).append("} as a copy of the specified {@link ").append(className).append("} instance. */\n");
      out.append("    public ").append(classSimpleName).append("(final ").append(className).append(" copy) {\n");
      out.append("      this(copy, true);\n");
      out.append("    }\n\n");

      out.append("    /** Creates a new {@link ").append(className).append("} as a copy of the specified {@link ").append(className).append("} instance. */\n");
      out.append("    ").append(classSimpleName).append("(final ").append(className).append(" copy, final boolean wasSet) {\n");
      out.append("      this(true, false, ").append(init).append(", copy, wasSet);\n");
      out.append("    }\n\n");
    }

    out.append("    ").append(classSimpleName).append("(final boolean _mutable$, final boolean _wasSelected$, final ").append(data.Column.class.getCanonicalName()).append("<?>[] _column$, final ").append(data.Column.class.getCanonicalName()).append("<?>[] _primary$, final ").append(data.Column.class.getCanonicalName()).append("<?>[] _keyForUpdate$, final ").append(data.Column.class.getCanonicalName()).append("<?>[] _auto$, final ").append(className).append(" copy, final boolean wasSet) {\n");
    out.append("      super(_mutable$, _wasSelected$, _column$, _primary$, _keyForUpdate$, _auto$");
    if (table.getExtends$() != null)
      out.append(", copy, wasSet");
    out.append(");\n");

    int primaryIndex = info.totalPrimaryCount.offset;
    int keyForUpdateIndex = info.totalKeyForUpdateCount.offset;
    int autoIndex = info.totalAutoCount.offset;
    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i) {
      if (i > s)
        out.append('\n');

      final Type type = types[i];
      out.append("      _column$[").append(i).append("] = ");
      if (type.isPrimary)
        out.append("_primary$[").append(primaryIndex++).append("] = ");

      if (type.keyForUpdate)
        out.append("_keyForUpdate$[").append(keyForUpdateIndex++).append("] = ");

      if (org.jaxdb.ddlx.Generator.isAuto(type.column))
        out.append("_auto$[").append(autoIndex++).append("] = ");

      type.assignColumn(out);
    }

    out.append('\n');
    out.append("      if (copy != null) {\n");
    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i) {
      if (i > s)
        out.append('\n');

      final Type type = types[i];
      final String fieldName = Identifiers.toCamelCase(type.column.getName$().text());
      out.append("        this.").append(fieldName).append(".copy(copy.").append(fieldName).append(", wasSet);");
    }
    out.append("\n      }\n");
    out.append("    }\n\n");

    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    void _merge$(final ").append(info.rootClassName).append(" table, final ").append(data.class.getName()).append(".Merge merge) {\n");
    if (table.getExtends$() != null) {
      out.append("      super.merge(table, merge);\n");
      out.append("      final ").append(className).append(" t = (").append(className).append(")table;\n");
    }
    else {
      out.append("      final ").append(className).append(" t = table;\n");
    }

    boolean hasColumnsToMerge = false;
    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i) {
      final Type type = types[i];
      if (!type.isPrimary) {
        if (hasColumnsToMerge)
          out.append('\n');

        hasColumnsToMerge = true;
        final String fieldName = Identifiers.toCamelCase(type.column.getName$().text());
        out.append("      if (t.").append(fieldName).append(".wasSet() || merge != null && ").append(fieldName).append(".generateOnUpdate != null)\n");
        out.append("        ").append(fieldName).append(".copy(t.").append(fieldName).append(", true);\n");
      }
    }
    out.append("    }\n");

    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i)
      out.append(types[i].declareColumn());

    out.append("\n\n");
//    out.append("    @").append(Override.class.getName()).append('\n');
//    out.append("    protected ").append(TableCache.class.getName()).append(" getRowCache() {\n");
//    out.append("      return ").append(schemaClassSimpleName).append(".getRowCache();\n");
//    out.append("    }\n\n");

    if (table.getAbstract$().text()) {
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public abstract ").append(className).append(" clone();\n\n");
    }
    else {
      out.append("    @").append(Override.class.getName()).append('\n');
      out.append("    public ").append(className).append(" clone() {\n");
      out.append("      return new ").append(className).append("(this, false);\n");
      out.append("    }\n\n");
    }

    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    public boolean equals(final ").append(Object.class.getName()).append(" obj) {\n");
    out.append("      if (obj == this)\n");
    out.append("        return true;\n\n");
    out.append("      if (!(obj instanceof ").append(className).append("))\n");
    out.append("        return false;\n\n");
    if (table.getExtends$() != null) {
      out.append("      if (!super.equals(obj))\n");
      out.append("        return false;\n\n");
    }

    out.append("      final ").append(className).append(" that = (").append(className).append(")obj;");
    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i) {
      final Type type = types[i];
      out.append("\n      if (this.").append(type.getInstanceName()).append(".isNull() ? !that.").append(type.getInstanceName()).append(".isNull() : !this.").append(type.getInstanceName()).append(".get().equals(that.").append(type.getInstanceName()).append(".get()))");
      out.append("\n        return false;\n");
    }

    out.append("\n      return true;");
    out.append("\n    }\n\n");

    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    public int hashCode() {\n");
    if (table.getExtends$() != null)
      out.append("      int hashCode = super.hashCode();");
    else
      out.append("      int hashCode = ").append(tableName.hashCode()).append(";");

    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i) {
      final Type type = types[i];
      out.append("\n      if (!this.").append(type.getInstanceName()).append(".isNull())");
      out.append("\n        hashCode = 31 * hashCode + this.").append(type.getInstanceName()).append(".get().hashCode();\n");
    }
    out.append("\n      return hashCode;");
    out.append("\n    }\n\n");

    out.append("    @").append(Override.class.getName()).append('\n');
    out.append("    protected void toString(final boolean wasSetOnly, final ").append(StringBuilder.class.getName()).append(" s) {\n");
    if (table.getExtends$() != null)
      out.append("      super.toString(wasSetOnly, s);");

    for (int s = types.length - noColumnsLocal, i = s; i < types.length; ++i) {
      final Type type = types[i];
      final boolean ifClause = !type.isPrimary && !type.keyForUpdate;
      if (ifClause)
        out.append("      if (!wasSetOnly || this.").append(type.getInstanceName()).append(".wasSet)\n  ");

      out.append("      s.append(\",\\\"").append(type.column.getName$().text()).append("\\\":\").append(this.").append(type.getInstanceName()).append(".toJson());\n");
      if (ifClause)
        out.append('\n');
    }

    out.append("      s.setCharAt(0, '{');\n");
    out.append("      s.append('}');");
    out.append("\n    }");
    out.append("\n  }");
    return out.toString();
  }

  private StringBuilder getClassNameOfTable(final StringBuilder out, final Table table) {
    return out.append(schemaClassName).append('.').append(Identifiers.toClassCase(table.getName$().text()));
  }

  private StringBuilder getClassNameOfEnum(final Table table, final $Column column) {
    final StringBuilder out = new StringBuilder();
    if (column.getTemplate$() != null)
      return out.append(schemaClassName).append('.').append(Identifiers.toClassCase(column.getTemplate$().text()));

    return getClassNameOfTable(out, table).append('.').append(Identifiers.toClassCase(column.getName$().text()));
  }
}