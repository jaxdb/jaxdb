/* Copyright (c) 2022 JAX-DB
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * You should have received a copy of The MIT License (MIT) along with this
 * program. If not, see <http://opensource.org/licenses/MIT/>.
 */

package org.jaxdb.jsql;

import static org.libj.lang.Assertions.*;

import java.util.ArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import java.util.function.IntConsumer;

import org.jaxdb.jsql.statement.NotifiableModification.NotifiableResult;
import org.libj.util.MultiHashMap;
import org.libj.util.MultiMap;
import org.libj.util.function.ThrowingObjBiIntPredicate;

public final class Callbacks {
  public interface OnExecute extends IntConsumer {
  }

  public interface OnCommit extends IntConsumer {
  }

  public interface OnRollback extends Runnable {
  }

  /**
   * Predicate to be called for each notification generated by the DB as a result of the statement to which {@code this}
   * {@link OnNotify} is associated, with the following parameters:
   * <ol>
   * <li><code>({@link Exception} t)</code>: An exception that occurs while waiting for a notification generated by the DB.</li>
   * <li>{@code (int v1)}: The {@code index} of the notification generated by the DB.</li>
   * <li>{@code (int v2)}: The total {@code count} of the notifications expected to be generated by the DB.</li>
   * </ol>
   * Since the notifications generated by the DB are asynchronous, {@link NotifiableResult#awaitNotify(long)} can be used to block
   * the current thread until:
   * <ul>
   * <li>the return from {@link Callbacks.OnNotify OnNotify#test(Exception,int,int)} is {@code false}.</li>
   * <li>the receipt of all notifications generated by the DB as a result of {@code this} statement, or</li>
   * </ul>
   */
  public interface OnNotify extends ThrowingObjBiIntPredicate<Exception,Exception> {
  }

  static class OnNotifyCallback implements ThrowingObjBiIntPredicate<Exception,Exception> {
    final OnNotify onNotify;
    final Boolean b;

    OnNotifyCallback(final OnNotify onNotify) {
      this.onNotify = assertNotNull(onNotify);
      this.b = null;
    }

    OnNotifyCallback(final boolean onNotify) {
      this.onNotify = null;
      this.b = onNotify;
    }

    @Override
    public boolean testThrows(final Exception e, final int index, final int count) throws Exception {
      if (onNotify != null)
        return onNotify.test(e, index, count);

      if (e != null)
        throw e;

      return b;
    }
  }

  static class OnNotifies extends ArrayList<OnNotifyCallback> implements Consumer<Exception> {
    private final AtomicInteger count = new AtomicInteger();
    private final AtomicInteger index = new AtomicInteger();
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    OnNotifies() {
    }

    boolean await(final long timeout) throws InterruptedException {
      if (timeout <= 0)
        return false;

      if (size() == 0)
        return true;

      int index = this.index.get();
      int count = this.count.get();
      if (index == count) {
        clear();
        return true;
      }

      lock.lock();
      try {
        index = this.index.get();
        count = this.count.get();
        return index == count || condition.await(timeout, TimeUnit.MILLISECONDS) || this.index.get() == this.count.get();
      }
      finally {
        lock.unlock();
        clear();
      }
    }

    private void accept(final Exception e, final int index, final int count, final int i, final int size) {
      if (i == size)
        return;

      final boolean keep = get(i).test(e, index, count);
      accept(e, index, count, i + 1, size);
      if (!keep)
        remove(i);
    }

    @Override
    public void accept(final Exception e) {
      final int index = this.index.incrementAndGet();
      final int count = this.count.get();
      if (index > count)
        throw new IllegalStateException();

      try {
        accept(e, index, count, 0, size());
      }
      finally {
        if (index == count || size() == 0) {
          lock.lock();
          try {
            condition.signal();
          }
          finally {
            lock.unlock();
            clear();
          }
        }
      }
    }
  }

  ArrayList<OnExecute> onExecutes;
  ArrayList<OnCommit> onCommits;
  ArrayList<OnRollback> onRollbacks;
  MultiMap<String,OnNotifyCallback,OnNotifies> onNotifys;

  ArrayList<OnExecute> getOnExecutes() {
    return onExecutes == null ? onExecutes = new ArrayList<>() : onExecutes;
  }

  ArrayList<OnCommit> getOnCommits() {
    return onCommits == null ? onCommits = new ArrayList<>() : onCommits;
  }

  ArrayList<OnRollback> getOnRollbacks() {
    return onRollbacks == null ? onRollbacks = new ArrayList<>() : onRollbacks;
  }

  MultiMap<String,OnNotifyCallback,OnNotifies> getOnNotifys() {
    return onNotifys == null ? onNotifys = new MultiHashMap<>(OnNotifies::new) : onNotifys;
  }

  void onExecute(final String sessionId, final int count) {
    if (onExecutes != null) {
      final ArrayList<OnExecute> onExecutes = this.onExecutes;
      final int size = onExecutes.size();
      if (size == 0)
        return;

      try {
        for (int i = 0; i < size; ++i) // [RA]
          onExecutes.get(i).accept(count);
      }
      finally {
        onExecutes.clear();
      }
    }

    final OnNotifies onNotifies;
    if (sessionId != null && (onNotifies = onNotifys.get(sessionId)) != null)
      onNotifies.count.set(count);
  }

  void onCommit(final int count) {
    if (onCommits != null) {
      final ArrayList<OnCommit> onCommits = this.onCommits;
      final int size = onCommits.size();
      if (size == 0)
        return;

      try {
        for (int i = 0; i < size; ++i) // [RA]
          onCommits.get(i).accept(count);
      }
      finally {
        onCommits.clear();
      }
    }
  }

  void onRollback() {
    if (onRollbacks != null) {
      final ArrayList<OnRollback> onRollbacks = this.onRollbacks;
      final int size = onRollbacks.size();
      if (size == 0)
        return;

      try {
        for (int i = 0; i < size; ++i) // [RA]
          onRollbacks.get(i).run();
      }
      finally {
        onRollbacks.clear();
      }
    }
  }

  void clear() {
    if (onExecutes != null)
      onExecutes.clear();

    if (onCommits != null)
      onCommits.clear();

    if (onRollbacks != null)
      onRollbacks.clear();

    if (onNotifys != null)
      onNotifys.clear();
  }

  Callbacks() {
  }
}