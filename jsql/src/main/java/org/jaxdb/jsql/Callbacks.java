/* Copyright (c) 2022 JAX-DB
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * You should have received a copy of The MIT License (MIT) along with this
 * program. If not, see <http://opensource.org/licenses/MIT/>.
 */

package org.jaxdb.jsql;

import static org.libj.lang.Assertions.*;

import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.IntConsumer;
import java.util.function.Predicate;

import org.jaxdb.jsql.statement.NotifiableModification.NotifiableResult;
import org.libj.util.DelegateCollection;
import org.libj.util.MultiHashMap;
import org.libj.util.MultiMap;
import org.libj.util.function.ThrowingObjBiIntPredicate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public final class Callbacks {
  private static final Logger logger = LoggerFactory.getLogger(Callbacks.class);

  public interface OnExecute extends IntConsumer {
  }

  public interface OnCommit extends IntConsumer {
  }

  public interface OnRollback extends Runnable {
  }

  /**
   * Predicate to be called for each notification generated by the DB as a result of the statement to which {@code this}
   * {@link OnNotify} is associated, with the following parameters:
   * <ol>
   * <li><code>({@link Exception} t)</code>: An exception that occurs while waiting for a notification generated by the DB.</li>
   * <li>{@code (int v1)}: The {@code index} of the notification generated by the DB.</li>
   * <li>{@code (int v2)}: The total {@code count} of the notifications expected to be generated by the DB.</li>
   * </ol>
   * Since the notifications generated by the DB are asynchronous, {@link NotifiableResult#awaitNotify(long)} can be used to block
   * the current thread until:
   * <ul>
   * <li>the return from {@link Callbacks.OnNotify OnNotify#test(Exception,int,int)} is {@code false}.</li>
   * <li>the receipt of all notifications generated by the DB as a result of {@code this} statement, or</li>
   * </ul>
   */
  public interface OnNotify extends ThrowingObjBiIntPredicate<Exception,Exception> {
  }

  static class OnNotifyCallback implements ThrowingObjBiIntPredicate<Exception,Exception> {
    final OnNotify onNotify;
    final Boolean b;
    final AtomicReference<OnNotifyCallback> next = new AtomicReference<>();

    OnNotifyCallback(final OnNotify onNotify) {
      this.onNotify = assertNotNull(onNotify);
      this.b = null;
    }

    OnNotifyCallback(final boolean onNotify) {
      this.onNotify = null;
      this.b = onNotify;
    }

    @Override
    public boolean testThrows(final Exception e, final int index, final int count) throws Exception {
      if (onNotify != null)
        return onNotify.test(e, index, count);

      if (e != null)
        throw e;

      return b;
    }
  }

  static class OnNotifyCallbackList extends DelegateCollection<OnNotifyCallback> implements Predicate<Exception> {
    private final AtomicInteger count = new AtomicInteger();
    private final AtomicInteger index = new AtomicInteger();
    private final AtomicReference<OnNotifyCallback> root = new AtomicReference<>();
    private final AtomicReference<OnNotifyCallback> head = new AtomicReference<>();

    OnNotifyCallbackList() {
    }

    boolean await(final long timeout) throws InterruptedException {
      if (timeout <= 0)
        return false;

      if (isEmpty())
        return true;

      int index = this.index.get();
      int count = this.count.get();
      if (index == count) {
        clear();
        return true;
      }

      synchronized (this.count) {
        try {
          index = this.index.get();
          count = this.count.get();
          if (index == count)
            return true;

          final long ts = System.currentTimeMillis();
          this.count.wait(timeout);
          return System.currentTimeMillis() - ts < timeout || this.index.get() == this.count.get();
        }
        finally {
          clear();
        }
      }
    }

    @Override
    public boolean test(final Exception e) {
      final int index = this.index.incrementAndGet();
      final int count = this.count.get();
      if (index > count)
        throw new IllegalStateException("index (" + index + ") > count (" + count + ")");

      final boolean finished;
      try {
        synchronized (head) { // FIXME: I think synchronized is not necessary, this code should only ever be executed synchronously anyway
          OnNotifyCallback prev = null;
          for (OnNotifyCallback next, cursor = root.get(); cursor != null; prev = cursor, cursor = next) {
            next = cursor.next.get();

            boolean retain;
            try {
              retain = cursor.testThrows(e, index, count);
            }
            catch (final Exception e1) {
              if (logger.isWarnEnabled()) logger.warn(e1.getMessage(), e1);
              retain = false;
            }

            if (!retain) {
              if (prev != null)
                prev.next.set(next);
              else
                root.set(next);
            }
          }

          head.set(prev);
        }
      }
      finally {
        if (finished = index == count || isEmpty()) {
          synchronized (this.count) {
            this.count.notify();
            clear();
          }
        }
      }

      return finished;
    }

    @Override
    public boolean add(final OnNotifyCallback e) {
      synchronized (head) {
        final OnNotifyCallback head = this.head.get();
        if (head != null)
          head.next.set(e);
        else
          root.set(e);
      }

      return true;
    }

    @Override
    public void clear() {
      synchronized (head) {
        root.set(null);
        head.set(null);
      }
    }

    @Override
    public boolean isEmpty() {
      return root == null;
    }
  }

  ArrayList<OnExecute> onExecutes;
  ArrayList<OnCommit> onCommits;
  ArrayList<OnRollback> onRollbacks;
  MultiMap<String,OnNotifyCallback,OnNotifyCallbackList> onNotifys;

  ArrayList<OnExecute> getOnExecutes() {
    return onExecutes == null ? onExecutes = new ArrayList<>() : onExecutes;
  }

  ArrayList<OnCommit> getOnCommits() {
    return onCommits == null ? onCommits = new ArrayList<>() : onCommits;
  }

  ArrayList<OnRollback> getOnRollbacks() {
    return onRollbacks == null ? onRollbacks = new ArrayList<>() : onRollbacks;
  }

  MultiMap<String,OnNotifyCallback,OnNotifyCallbackList> getOnNotifys() {
    return onNotifys == null ? onNotifys = new MultiHashMap<>(OnNotifyCallbackList::new) : onNotifys;
  }

  void onExecute(final String sessionId, final int count) {
    if (onExecutes != null) {
      final ArrayList<OnExecute> onExecutes = this.onExecutes;
      final int size = onExecutes.size();
      if (size == 0)
        return;

      try {
        int i = 0; do
          onExecutes.get(i).accept(count);
        while (++i < size); // [RA]
      }
      finally {
        onExecutes.clear();
      }
    }

    final OnNotifyCallbackList onNotifyCallbackList;
    if (sessionId != null && (onNotifyCallbackList = onNotifys.get(sessionId)) != null)
      onNotifyCallbackList.count.set(count);
  }

  void onCommit(final int count) {
    if (onCommits != null) {
      final ArrayList<OnCommit> onCommits = this.onCommits;
      final int size = onCommits.size();
      if (size == 0)
        return;

      try {
        int i = 0; do
          onCommits.get(i).accept(count);
        while (++i < size); // [RA]
      }
      finally {
        onCommits.clear();
      }
    }

    if (onRollbacks != null)
      onRollbacks.clear();
  }

  void onRollback() {
    if (onRollbacks != null) {
      final ArrayList<OnRollback> onRollbacks = this.onRollbacks;
      final int size = onRollbacks.size();
      if (size == 0)
        return;

      try {
        int i = 0; do
          onRollbacks.get(i).run();
        while (++i < size); // [RA]
      }
      finally {
        onRollbacks.clear();
      }
    }

    if (onCommits != null)
      onCommits.clear();
  }

  void merge(final Callbacks callbacks) {
    if (onCommits == null)
      onCommits = callbacks.onCommits;
    else
      onCommits.addAll(callbacks.onCommits);

    if (onRollbacks == null)
      onRollbacks = callbacks.onRollbacks;
    else
      onRollbacks.addAll(callbacks.onRollbacks);

    if (onNotifys == null) {
      onNotifys = callbacks.onNotifys;
    }
    else if (callbacks.onNotifys.size() > 0) {
      for (final Map.Entry<String,OnNotifyCallbackList> entry : callbacks.onNotifys.entrySet()) { // [S]
        final OnNotifyCallbackList list = onNotifys.get(entry.getKey());
        if (list != null)
          list.addAll(entry.getValue());
        else
          onNotifys.put(entry.getKey(), entry.getValue());
      }
    }
  }

  void clear() {
    if (onExecutes != null)
      onExecutes.clear();

    if (onCommits != null)
      onCommits.clear();

    if (onRollbacks != null)
      onRollbacks.clear();

    if (onNotifys != null)
      onNotifys.clear();
  }

  Callbacks() {
  }
}